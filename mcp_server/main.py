# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:15:52+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Path, Query

from models import (
    Criteria,
    DistanceUnit,
    OutputFormat,
    OutputFormat4,
    OutputFormat6,
    OutputFormat16,
    OutputFormat18,
    OutputSRS,
)

app = MCPProxy(
    contact={
        'name': 'Contact DataBC',
        'url': 'https://dpdd.atlassian.net/servicedesk/customer/portal/1/group/7/',
    },
    description='Finds shortest/fastest route between a start point and one or more stop points on British Columbia\'s public road network. The BC Route planner [webpage](https://www2.gov.bc.ca/gov/content?id=9D99E684CCD042CD88FADC51E079B4B5) provides additional information.  Here are some geocoded addresses to play with:<br>18 Douglas St,Victoria -123.36962,48.40892<br>1002 Johnson St, Victoria -123.355745,48.426206<br>543 Johnson St, Victoria, BC -123.36907,48.42770 <br>14 Centennial Sq, Victoria, BC -123.36564,48.42863<br>1105 Royal Ave,New Westminster  -122.92009,49.20063<br>808 Jackson Cres, New Westminster -122.90762,49.22558<br>10810 McDonald Rd, Chilliwack -121.93808,49.19859<br>3950 June Springs Rd, Kelowna -119.40751,49.83960<br>1201 Riondel Rd, Kootenay Bay -116.85402,49.74448<br>1201 Riondel Rd, Kootenay Bay -116.832759,49.730500 (parcelPoint)<br>2499 Walbran Pl, Courtenay -124.97295,49.71518<br>2013 Smoke Bluff Rd, Squamish -123.13946,49.70401<br>235 Kelvin Grove Way, Lions Bay -123.23524,49.45035<br>   Please see our <a href=https://github.com/bcgov/api-specs/blob/master/COLLECTION_NOTICE.md#collection-notice target="_blank">data collection notice</a>. \n\nPlease note that you may experience issues when submitting requests to the delivery or test environment if using this [OpenAPI specification](https://github.com/bcgov/api-specs) in other API console viewers. \n\n[API keys](https://api.gov.bc.ca/devportal/api-directory/740) are unique and can be acquired with a GitHub or IDIR account. \n\n',
    license={
        'name': 'Copyright Province of British Columbia - Access only',
        'url': 'https://www2.gov.bc.ca/gov/content?id=1AAACC9C65754E4D89A118B875E0FBDA',
    },
    termsOfService='http://www2.gov.bc.ca/gov/content?id=D1EE0A405E584363B205CD4353E02C88',
    title='BC Route Planner REST API',
    version='2.0.0',
    servers=[
        {'description': 'Production', 'url': 'https://router.api.gov.bc.ca/'},
        {'description': 'Test', 'url': 'https://routertst.api.gov.bc.ca/'},
        {'description': 'Delivery', 'url': 'https://router-dev.api.gov.bc.ca/'},
    ],
)


@app.get(
    '/directions.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between given start and end points """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_directions__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, path, distance and travel time between a series of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/directions.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between given start and end points """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_directions__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, path, distance and travel time between a series of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/distance.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest path between given start and end points. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_distance__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get distance and travel time between two geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/distance.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest path between given start and end points. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_distance__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get distance and travel time between two geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/distance/betweenPairs.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest paths between all pairs of fromPoints and toPoints. The number of fromPoints times the number of toPoints should not exceed 100 or the request will time out. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_distance_between_pairs__output_format(
    output_format: OutputFormat4 = Path(..., alias='outputFormat'),
    from_points: str = Query(..., alias='fromPoints'),
    to_points: str = Query(..., alias='toPoints'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
    max_pairs: Optional[int] = Query(None, alias='maxPairs'),
):
    """
    Get distance and travel time between each pair of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/distance/betweenPairs.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest paths between all pairs of fromPoints and toPoints. The number of fromPoints times the number of toPoints should not exceed 100 or the request will time out. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_distance_between_pairs__output_format(
    output_format: OutputFormat4 = Path(..., alias='outputFormat'),
    from_points: str = Query(..., alias='fromPoints'),
    to_points: str = Query(..., alias='toPoints'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
    max_pairs: Optional[int] = Query(None, alias='maxPairs'),
):
    """
    Get distance and travel time between each pair of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/optimalDirections.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between a start point and a series of end points which are reordered to minimize distance/time """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_optimal_directions__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, optimal path, distance and travel time between a start point and a series of end points which are reordered to minimize total distance or time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/optimalDirections.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between a start point and one or more end points which are reordered to minimize distance or time. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_optimal_directions__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, optimal path, distance and travel time between a start point and one or more end points which are reordered to minimize total distance or time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/optimalRoute.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between a start point and a series of end points which are reordered to minimize distance or time """,
    tags=['routing_operations', 'optimal_route_finding', 'distance_calculation'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_optimal_route__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the optimal path, distance and travel time between a start point and a series of end points which are reordered to minimize total distance or time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/optimalRoute.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between a start point and a series of end points which are reordered to minimize total distance or time. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_optimal_route__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the path, distance and travel time between a start point and a series of end points which are reordered to minimize total distance or time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/route.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between given start and end points. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_route__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the path, distance and travel time between a series of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/route.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between given start and end points. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_route__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the path, distance and travel time between a series of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/truck/directions.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between given start and end points for a commercial vehicle """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_truck_directions__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, path, distance and travel time between a series of geographic points for a commercial vehicle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/truck/directions.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between given start and end points """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_truck_directions__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, path, distance and travel time between a series of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/truck/distance.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest path between given start and end points. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_truck_distance__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get distance and travel time between two geographic points for a commercial vehicle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/truck/distance.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest path between given start and end points. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_truck_distance__output_format(
    output_format: OutputFormat6 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get distance and travel time between two geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/truck/distance/betweenPairs.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest paths between all pairs of fromPoints and toPoints for a commercial vehicle. The number of fromPoints times the number of toPoints should not exceed 100 or the request will time out. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_truck_distance_between_pairs__output_format(
    output_format: OutputFormat16 = Path(..., alias='outputFormat'),
    from_points: str = Query(..., alias='fromPoints'),
    to_points: str = Query(..., alias='toPoints'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
    max_pairs: Optional[int] = Query(None, alias='maxPairs'),
):
    """
    Get distance and travel time between each pair of geographic points for a commercial vehicle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/truck/distance/betweenPairs.{outputFormat}',
    description=""" Represents the distance and time of the shortest or fastest paths between all pairs of fromPoints and toPoints. The number of fromPoints times the number of toPoints should not exceed 100 or the request will time out. """,
    tags=['routing_operations', 'distance_calculation', 'optimal_route_finding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_truck_distance_between_pairs__output_format(
    output_format: OutputFormat16 = Path(..., alias='outputFormat'),
    from_points: str = Query(..., alias='fromPoints'),
    to_points: str = Query(..., alias='toPoints'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
    max_pairs: Optional[int] = Query(None, alias='maxPairs'),
):
    """
    Get distance and travel time between each pair of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/truck/optimalDirections.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between a start point and a series of end points which are reordered to minimize distance/time for a commercial vehicle. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_truck_optimal_directions__output_format(
    output_format: OutputFormat18 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, optimal path, distance and travel time between a start point and a series of end points which are reordered to minimize total distance or time for a commercial vehicle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/truck/optimalDirections.{outputFormat}',
    description=""" Represents the turn-by-turn directions, geometry, distance, and time of the shortest path or fastest path between a start point and one or more end points which are reordered to minimize distance or time. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_truck_optimal_directions__output_format(
    output_format: OutputFormat18 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the directions, optimal path, distance and travel time between a start point and one or more end points which are reordered to minimize total distance or time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/truck/optimalRoute.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between a start point and a series of end points which are reordered to minimize distance or time for a commercial vehicle. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_truck_optimal_route__output_format(
    output_format: OutputFormat18 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the optimal path, distance and travel time between a start point and a series of end points which are reordered to minimize total distance or time for a commercial vehicle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/truck/optimalRoute.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between a start point and a series of end points which are reordered to minimize total distance or time. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_truck_optimal_route__output_format(
    output_format: OutputFormat18 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the path, distance and travel time between a start point and a series of end points which are reordered to minimize total distance or time.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/truck/route.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between given start and end points for a commercial vehicle. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_truck_route__output_format(
    output_format: OutputFormat18 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the path, distance and travel time between a series of geographic points for a commercial vehicle
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/truck/route.{outputFormat}',
    description=""" Represents the geometry, distance, and time of the shortest or fastest path between given start and end points. """,
    tags=[
        'routing_operations',
        'commercial_vehicle_routing',
        'distance_calculation',
        'optimal_route_finding',
    ],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def post_truck_route__output_format(
    output_format: OutputFormat18 = Path(..., alias='outputFormat'),
    points: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    criteria: Optional[Criteria] = 'shortest',
    distance_unit: Optional[DistanceUnit] = Query('km', alias='distanceUnit'),
    round_trip: Optional[bool] = Query(False, alias='roundTrip'),
    departure: Optional[datetime] = None,
    correct_side: Optional[bool] = Query(False, alias='correctSide'),
    truck_route_multiplier: Optional[int] = Query(9, alias='truckRouteMultiplier'),
    partition: Optional[str] = '',
    disable: Optional[str] = 'sc,tf,ev,td',
    route_description: Optional[str] = Query(
        'Routing results', alias='routeDescription'
    ),
):
    """
    Get the path, distance and travel time between a series of geographic points
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
